<html lang="en-US"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link type="text/css" href="/css/styles.css" rel="stylesheet"/><link type="text/css" href="/css/fontawesome.min.css" rel="stylesheet"/><link rel="stylesheet" href="css/github.min.css"/><link href="css/prism-one-light.css" rel="stylesheet"/><link rel="stylesheet" href="https://unpkg.com/katex@latest/dist/katex.min.css"/><link href="https://fonts.googleapis.com/css?family=Nunito:400,700&amp;display=swap" rel="stylesheet"/></head><body class="w-full"><ul class="flex border-b mt-2 fixed-top mx-2"><a class="bg-white inline-block border-l border-t border-r rounded-t py-4 px-4 text-black font-semibold active_text-orange" id="home_tab" href="/">Home</a><a class="bg-white inline-block border-l border-t border-r rounded-t py-4 px-4 text-black font-semibold active_text-orange" id="about_tab" href="/about">About</a><div class="mt-0 ml-auto relative box-border mb-4 w-5/12"><input class="bg-white border-l rounded border appearance-none leading-normal pl-4 pr-8 w-full h-full outline-none my-2" id="search_box" placeholder="Search..." type="search" name="search"/><button class="fa fa-search absolute right-0 top-2 h-full my-2 mr-6" aria-hidden="true" style="align-middle"></button></div></ul><div class="mx-2 flex border mb-6 border-t-0"><div class="markdown container px-16 items-center w-full max-w-screen-xl mx-auto prose prose-pre_p-2 prose-pre_border-2"><h1 class="my-4">The Beauty of C++</h1><small class="text-orange my-0">Author: </small><small class="text-gray my-0">Matt Piekenbrock</small><br/><small class="text-orange my-0">Date:</small><small class="text-gray my-0"> 2017-03-01</small><div class="w-full" id="page_content"> </div>

<p>Most code written today, in some way shape or form, is either written in or depends on C++.</p>
<p>This includes, for example, most of the modern interpreted languages.</p>
<p>C++ is a beautiful language. There, I said it.</p>
<p>Before I get my inbox flooded with snippets of the ugliness of templates or links showing the differences, hear me out.</p>
<div id="c-is-an-apple-not-an-orange." class="section level2">
<h2>C++ is an apple, not an orange.</h2>
<p>C++ is typically thought of as an <em>ugly</em> language. Many devs who say this will far too quickly point to examples showing how many more lines it takes to write something in C++ than in Python. For example,</p>
<p>This is a straw-mans argument. C++ is a compiled language. Python, Ruby, R, Perl, etc. are interpreted languages. It is simply not fair to compare them.</p>
<p>Let’s assume the contrary, that it <em>is</em> fair to compare them. After all, if two given sets of source code encode the same logic,
why not start looking effiency-to-productivity ratios and maximize accordingly?</p>
<p>One of the core principles that has always been a philosophical cornerstone of C++ is the principle of <em>zero-cost abstraction</em>. That is, the notion
that if one intends to add something to the language, it ought to be better than any code 99% of programmers could code up themselves. More exactly,
the code should not just add higher-order functionality—it must offer an abstraction that the programmer can use effectively at <em>zero</em> (or near-zero)
cost to themselves.</p>
<p>Here is a very deep statement: maintaining the <em>zero-cost abstraction</em> principle is <em>hard</em>. It is <em>hard</em> to write abstractions that come at no cost to the programmer.</p>
<p>Let’s see some examples.</p>
</div>
<div id="abstractions-are-easy.-good-abstractions-are-hard." class="section level2">
<h2>Abstractions are easy. Good abstractions are hard.</h2>
<p>This begs the question, <em>how</em> does one create an abstraction that is <em>zero-cost</em>?</p>
<p>A famous quote that rings truer to closer one gets to the hardware is the following:</p>
<pre><code>All problems in computer science can be solved by another level of indirection... except for the problem of too many layers of indirection.</code></pre>
<p>Well, to me there are two aspects to it, each being difficult in very different ways.</p>
<p>There’s the efficiency side of it: a zero-cost abstraction ought to be just as <em>efficient</em> as something a programmer might write himeself. This,
to me, comes down to an engineering problem—ensure the number of assembly instructions generated by the abstraction is minimal.</p>
<p>Then, there’s the much more difficult side of it: the <em>design</em> aspect. The abstraction should solve a problem not already solved by other constructions.
This is truly the most difficult aspect of all. <a href="https://www.youtube.com/watch?v=fThhbt23SGM">Design is a search problem</a>.</p>
<p>I’ll quote Mike Bostock here:</p>
<p>Talking about design is hard because design is hard.</p>
<p>There’s quite a lot of code out there. But every programmer who has thought about any previous code they’ve ever written has inevitably
had the following experience:</p>
<ol style="list-style-type: decimal">
<li>Write a function that does something</li>
<li>Write a function that works with the first function</li>
<li>Realize that the first function can be encapsulated by the second.</li>
</ol>
<p>Another aspect of design is the it is subjective.</p>
</div>
<div id="what-is-working" class="section level2">
<h2>What is working</h2>
<p>Functional programming. Compile-time expressions. SFINAE and its emergent simplicity: <a href="https://www.youtube.com/watch?v=PFdWqa68LmA&amp;feature=youtu.be" class="uri">https://www.youtube.com/watch?v=PFdWqa68LmA&amp;feature=youtu.be</a></p>
</div>
<div id="the-monad-example" class="section level2">
<h2>The Monad example</h2>
<p>Computer programming encodes logic. And anyone that studied functional programming knows that a sort of corner of of functional programming theory is
something known <em>category theory</em>.</p>
<p>Let’s look at a simple example.
std::optional and relationship to monad</p>
<p>Error codes and exception handling has been around for years. How does one approach the problem of handling the result of a function which
may fail to produce an output.</p>
<p>What if you want a function to return some object? A common approach is to create some kind ‘null’ object, or to return a pointer to the object
and return a <code>nullptr</code>.</p>
<p>In the former case, the object may be expensive to create.</p>
<p>The latter case can be used, but it is hard to compose. You still need to perform checking somewhere: either</p>
<p>preconditions</p>
</div>
<div id="navigating-the-stars" class="section level2">
<h2>Navigating the stars</h2>
<p>Bartosz Mileweski proposed using Haskell as a language to design the TMP for C++.</p>
<p>Picture of waveforms vs music notes.</p>
</div>
<div id="more-real-world-examples" class="section level2">
<h2>More real-world examples</h2>
<p>kdtools</p>
<p> C++ is about taking an existing set of tools and really looking deep at how they might be used differently, in a completely new way. The result is often a 
  new feature of the language, added either explicitly or discovered and used later on.   
<p> For example, in 198x C++ released support for classes. But now lambdas are just objects with a different syntax. Thats an explicit example. </p>
<p> Another example, implicit, is inheritence, which came with object oriented programming. Inheritence is generally regarded as evil, and practicioners 
  often advise against it, preferring composition instead. There are many ways of achieving composition in C++; strategy pattern, delegation pattern, higher-order functions, visitor pattern: one example that emphasizes that components 
  must be re-useable and small is the development of _mixins_. _mixins_ are really just abusing CRTP. 
</div>
<div id="conclusions" class="section level2">
<h2>Conclusions</h2>
<p>Anyone can create a simple language to do whatever abstraction they could dream of.
The fact that C++ demands its abstractions to be zer-cost is a highly non-trivial constraint to satisfy.
Yet time passes. Advances are made. The fact that the lambda was a game-changer
C++ is an evolving language, and advances in making these abstractions is becoming more popular.
Indeed, there are some tasks that one can write incredibly concisely in modern C++ that is near the line-count
and readability of some of the interpreted languages. And in all but pathological, misconstrewed examples, the C++
solution <em>will</em> be faster than the interpreseted equivalents, by design.</p>
<p>And how did that happen? Intrinsically simple, carefully thought out components were skillfully woven
together in a way that carried no baggage, no extraneous cost. The result is simple to read, simple to
write code that solves a complex problem by breaking it into simple parts.
To me, that is what makes C++ a beautiful language.</p>
</div>
<br/></div></div><script src="js/jquery.min.js"></script><script src="js/elasticlunr.min.js"></script><script src="js/lodash.min.js"></script><script>document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((block) => {
    console.log("here");
    //hljs.highlightBlock(block);
  });
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/js/all.js" integrity="sha256-2JRzNxMJiS0aHOJjG+liqsEOuBb6++9cY4dSOyiijX4=" crossorigin="anonymous"></script><script>const tabs = ["home_tab", "about_tab"];
tabs.forEach((tab_id) => {
	var tab_el = document.getElementById(tab_id)
	console.log(window.location.pathname.replace("/", ""))
	console.log(tab_el.pathname.replace("/", ""))
	if (window.location.pathname == tab_el.pathname){
		console.log("orange")
		tab_el.classList.remove("text-black")
		tab_el.classList.add("text-orange")
	} else {
		console.log("black")
		tab_el.classList.remove("text-orange")
		tab_el.classList.add("text-black")
	}
})</script><script>var search_index, doc_keys;

const apply_slugs = (slugs, display_status) => {
	_.forEach(slugs, (id) => { if (id){ $("#"+id).css("display", display_status); } });
};

$.getJSON('/data/cached_index.json', function(data) {
	search_index = elasticlunr.Index.load(data);
	doc_keys = _.map(search_index.documentStore.docs, (doc) => {
		return (doc.slug ? doc.slug : "");
	});
	console.log("Search index")
	console.log(search_index);
});


const feed = $("#article_feed");
const all_articles = $("#article_feed").children();
//- const article_ids = _.map(all_articles, (article) => { 
//- 	return article.id.replace(/-/g, "_")
//- })	

console.log("Articles: ")
console.log(all_articles)

function update_search_box() {
	var searchstring = $('#search_box');
	searchstring.focus();
	
	console.log(searchstring.val())

	// If query empty, default to listing all the articles
	if (searchstring.val().trim() == ""){
		if (feed.children().length != all_articles.length){
			feed.children().detach()
			feed.append(all_articles);
		}
	} else {
		var res = search_index.search(searchstring.val(), {});
		const found_slugs = _.map(res, (doc) => { return doc.ref; });
		console.log(found_slugs)
		const ordered_articles = _.map(found_slugs, (slug) => {
			return _.find(all_articles, (article) => { return article.id.replace(/-/g, "_") == slug.replace(/-/g, "_") });
		});
		feed.children().detach()
		_.forEach(ordered_articles, (arr) => {
			feed.append(arr);
			feed.append(document.createElement("br"))
		});
	}
}

$( "#search_box" ).keyup(update_search_box);</script></body><footer class="fixed text-center bottom-0 bg-gray-100 border w-full"><span>&copy; Copyright Matt Piekenbrock 2022. Proudly powered by </span><a href="https://www.11ty.dev/">Eleventy.</a><script>$(document).ready(function() {
  $("[data-link]").click(function() {
    window.location.href = $(this).attr("data-link");
    return false;
  });
});</script></footer></html>