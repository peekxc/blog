<html lang="en-US"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link type="text/css" href="css/styles.css" rel="stylesheet"/><link rel="stylesheet" href="css/github.min.css"/><link href="css/prism-one-light.css" rel="stylesheet"/><link rel="stylesheet" href="https://unpkg.com/katex@latest/dist/katex.min.css"/><link href="https://fonts.googleapis.com/css?family=Nunito:400,700&amp;display=swap" rel="stylesheet"/></head><body class="w-full"><ul class="flex border-b mt-2 fixed-top mx-2"><a class="bg-white inline-block border-l border-t border-r rounded-t py-4 px-4 text-black font-semibold active_text-orange" id="home_tab" href="/blog/">Home</a><a class="bg-white inline-block border-l border-t border-r rounded-t py-4 px-4 text-black font-semibold active_text-orange" id="about_tab" href="/blog/about">About</a><div class="mt-0 ml-auto relative box-border mb-4 w-5/12"><input class="bg-white border-l rounded border appearance-none leading-normal pl-4 pr-8 w-full h-full outline-none my-2" id="search_box" placeholder="Search..." type="search" name="search"/><button class="fa fa-search absolute right-0 top-2 h-full my-2 mr-6" aria-hidden="true" style="align-middle"></button></div></ul><div class="mx-2 flex border mb-6 border-t-0"><div class="markdown container px-16 items-center w-full max-w-screen-xl mx-auto prose prose-pre_p-2 prose-pre_border-2"><h1 class="my-4">Is C++ a Functional Programming Language?</h1><small class="text-orange my-0">Author: </small><small class="text-gray my-0">Matt Piekenbrock</small><br/><small class="text-orange my-0">Date:</small><small class="text-gray my-0"> 2017-03-01</small><div class="w-full" id="page_content"> </div><h1>Functional Programming</h1>
<p>What is a functional programming (FP) language? Definitions vary. Here are a few:</p>
<ul>
<li>A FP languages is any language which has a wealth of support for things typically associated with the FP paradigm</li>
<li>A FP language typically involving composing <strong>pure functions</strong>, avoiding <strong>shared state,</strong> <strong>mutable data,</strong> and <strong>side-effects</strong>.</li>
<li>A FP language is sometimes also defined as a language which treats functions as <em>first-class citizens</em></li>
</ul>
<p>FP is sometimes considerd a <em>declarative</em> style of programming, because the program logic is expressed through the compositions of pure functions, which transform values into new values, rather than constantly updating the internal state of existing variables (e.g. as one might in the OOP paradigm with member fields).</p>
<p>Consider the 3rd definition of a FP language in the list above, as it is the explicit. Generally, a language that treats a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> as a <em>first-class citizen</em> means essentially that the language has mechanisms supporting the use of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> types in ways similar to its support for its native types. For example, in C an <code>int</code> is a native type which one can do just about anything you want with at the language level (e.g. you can make <code>int</code> variables, pass <code>int&amp;</code> references, create <code>int*</code> pointers, etc.). Stricter definitions of first-class citizens require said types to be passable as arguments to functions, returnable from function calls, and assignable to variables. Thus, a FP language by definition (3) is just a language that supports some notion of a <code>function</code> type <em>natively</em>.</p>
<p>Under this definition, Python qualifies as a FP language as it supports functions as first-class citizens:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><br><span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><br><br><span class="token keyword">def</span> <span class="token function">eval_binary</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">return</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br>my_binary_op <span class="token operator">=</span> add<br>eval_binary<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>my_binary_op<span class="token punctuation">)</span><br><span class="token comment"># 9 </span><br><br>my_binary_op <span class="token operator">=</span> mul<br>eval_binary<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>my_binary_op<span class="token punctuation">)</span><br><span class="token comment"># 20</span></code></pre>
<p>You can do imitate this with function pointers in C via something like:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token keyword">double</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><br><span class="token keyword">double</span> <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>One can either pass pointers to the function definitions directly or more generically via a variable assignment:</p>
<pre class="language-cpp"><code class="language-cpp">  <span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_binary_op<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <br>  <br>  my_binary_op <span class="token operator">=</span> add<span class="token punctuation">;</span><br>  <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>my_binary_op<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => 9 </span><br>  <br>  my_binary_op <span class="token operator">=</span> mul<span class="token punctuation">;</span><br>  <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>my_binary_op<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => 20</span></code></pre>
<p>This sparks the following question: <em>does C qualify as full fledged FP language under the above first-class-citizen definition?</em></p>
<p>This article is dedicated to answering this question, and to introducing a few basic ideas of FP along the way. It is by no means comprehensive as general FP is a large topic area.</p>
<p>It may seem strange to interweave code examples written in Python with ones written in C++: these are two very different after all! Nonetheless, I conjecture understanding the nuances between how <em>functions</em> are implemented between these two languages illustrates nicely what is it really means to be a first class citizen. It also demonstrates quite nicely how far we've come as a society with the newest version of C++ at masking machine-level constraints with abstraction.</p>
<h1>Basic Functional Programming Concepts</h1>
<p>Here are many of the terms tossed around in FP:</p>
<ul>
<li><strong>Higher-Order Functions</strong> a function that accepts another function as an argument.</li>
<li><strong>Closure</strong> A function which <em>encloses</em> an <em>environment</em>. An <em>environment</em> is just a data structure that binds <em>symbols</em> to <em>values</em>.</li>
<li><strong>Currying</strong> the process of transforming a function that takes multiple arguments into a function that takes just a single argument and returns another function if any arguments are still needed. Not to be confused with <em>partial function application</em>.</li>
<li><strong>Pure Functions</strong> a function that does not enact <em>side effects</em>. Since pure function cannot mutate the state of its arguments, they must return a value--otherwise they are useless.</li>
<li><strong>Functors</strong> <a href="https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor">in the context of FP</a>, a functor is a container of type <em>a</em> that, when subjected to a function that maps from <em>a</em> → <em>b</em>, yields a container of type <em>b</em>. Replacing the words <em>container</em>, <em>type</em>, and <em>function</em> with the words <em>category</em>, <em>object</em>, and <em>morphism</em> yields a similar definition  of a functor in category theory.</li>
<li><strong>Monad</strong> A monad is just a <a href="https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">monoid in the category of endofunctors</a>. They enable things like the functional mutation of state in ways that adhere to FP principles. Understanding monads is a <a href="https://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/">like a spiritual experience</a> that must be taken alone.</li>
<li><strong>Immutable</strong> A variable is <em>immutable</em> if its value cannot change once its instantiated. In pure FP languages, all variables are immutable.</li>
<li><strong>Tail recursion</strong> A type of recursion wherein there is one recursive call whose result is left unmodified at the end of the body fo the recursive function (the tail), and the recursive call is the last operation to occur</li>
</ul>
<p>There are many other basic terms one needs to be familiar with, including <em>memoization</em>, [nullary/unary/binary/ternary] <em>functions</em>, <em>predicates</em>, delayed or &quot;<em>lazy</em>&quot; evaluation, <em>lambdas</em>, <em>y-combinators</em>, etc.</p>
<h2>Higher order functions and Closures</h2>
<p>A higher order function is a function that accepts a function as an argument. Thus, a programming language is not functional it does not support higher order, since part of the definition of a function being a first-class citizens is that it can be passed as an argument to a function.  We've already defined the higher order function <code>eval_binary</code>, which takes two numbers <code>a</code> and <code>b</code> and binary function <code>f</code> as input:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eval_binary</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">return</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>In the above code, <code>def</code> was to define a <em>named</em> function. A more compact style of defining a function is to define an <em>anonymous</em> <em>function</em>, or <em>lambda function</em>.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">lambda</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>f<span class="token punctuation">:</span> f<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span></code></pre>
<p>Note there is no <code>return</code> statement needed for <code>lambda</code> functions; its implicit in the last evaluated expression. Since Python treats functions as first class citizens, both named functions and lambas can be assigned to variables:</p>
<pre class="language-python"><code class="language-python">g <span class="token operator">=</span> <span class="token keyword">lambda</span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>f<span class="token punctuation">:</span> f<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span></code></pre>
<p>Although the lambda is bound to the symbol <code>g</code> and thus can be referred to by name, in general people will still refer to <code>lambda</code> functions as &quot;anonymous.&quot;</p>
<p>In most languages, there are subtle differences between anonymous functions and named functions. For example <a href="https://stackoverflow.com/questions/12264834/what-is-the-difference-for-python-between-lambda-and-regular-function">in Python</a>, a <code>lambda</code> expression is an expression which evaluates to a function object, while a <code>def</code> statement has no value: its creates a function object and binds it to a name. Moreover, <code>lambda</code> definitions are limited to single expressions.</p>
<p>A common example of a popular higher-order function is <code>map</code> and <code>reduce</code>. <code>map(f, iter)</code> takes as input a function <code>f</code> which it applies to every element along an iterable <code>it</code>. It then returns an iterable <code>map</code> object which can be enumerated to store as an explicit collection. For example:</p>
<pre class="language-python"><code class="language-python"><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><br><span class="token comment"># => &lt;map object at 0x7ffe66b26dc0></span><br><br><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment"># => [1, 4, 9, 16, 25]</span><br><br><span class="token builtin">tuple</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment"># => (1, 4, 9, 16, 25)</span><br><br><span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment"># => {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</span></code></pre>
<p>Sometimes its useful to have the function maintain an internal state. A <em>closure</em> is a function that does just this: it encapsulates its own lexical scope. Closures are typically constructed using the <em>factory pattern</em>.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cyclic_counter</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  c <span class="token operator">=</span> <span class="token number">0</span><br>  <span class="token keyword">def</span> <span class="token function">increment</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">nonlocal</span> c<br>    c <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> n<br>    <span class="token keyword">return</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><br>  <span class="token keyword">return</span><span class="token punctuation">(</span>increment<span class="token punctuation">)</span><br><br>counter <span class="token operator">=</span> cyclic_counter<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><br><br>counter<span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token comment"># => 1</span><br><br>counter<span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token comment"># => 2</span><br><br>counter<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><br><span class="token comment"># => 12</span></code></pre>
<p>Notice that the keyword <code>nonlocal</code> was used to denote the variable from the outer (enclosing) scope is writable. In contrast, since <code>n</code> is constant, it is available without the <code>nonlocal</code> keyword designation. See for <a href="https://stackoverflow.com/questions/4020419/why-arent-python-nested-functions-called-closures">this post</a> and <a href="https://stackoverflow.com/questions/1261875/python-nonlocal-statement">this post</a> for more information on Python closures and the <code>nonlocal</code> keyword.</p>
<hr>
<p>Functional programming is often distinguished as a distinct alternative from classical <em>Object Oriented Programming</em> (OOP), wherein state is modified within the object instance. In Python, a classic OOP to a <em>modulo n</em> counter might be something as follows:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CylicCounter</span><span class="token punctuation">:</span><br>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    self<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">0</span><br>    self<span class="token punctuation">.</span>n <span class="token operator">=</span> n<br>  <span class="token keyword">def</span> <span class="token function">increment</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    self<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>c <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>n<br>    <span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>c<span class="token punctuation">)</span><br>  <br>counter <span class="token operator">=</span> CyclicCounter<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><br>counter<span class="token punctuation">.</span>n</code></pre>
<p>So whats the difference between <a href="https://wiki.c2.com/?ClosuresAndObjectsAreEquivalent">a closure and an object</a>? Not much. A closure is a poor mans object, and an object is a poor mans closure. They both encapsulate an environment which contains bindings to mutables values, lexically scoped for each instantation. Despite their similarities, closures are more commonly used and recommended in FP, whereas objects are the bread and butter means of describing program logic in OOP. For example, the language <a href="">Clojure</a> is a popular FP language whose name was inspired by the use of the <em>closure</em> in FP.</p>
<h3>Detour: Closures in C and C++</h3>
<p>As shown above, the C language does not natively support closures at all. In C++, the canonical way of representing mutable data is by uses classes under the OOP paradigm. Consider the following pathologicial example of a fictional Dragon who breathes fire on villagers.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Dragon</span> <span class="token punctuation">{</span>  <br>  <span class="token keyword">const</span> <span class="token keyword">float</span> size<span class="token punctuation">;</span> <br>  <span class="token keyword">const</span> <span class="token keyword">float</span> height<span class="token punctuation">;</span> <br>  <span class="token keyword">float</span> fire_temperature<span class="token punctuation">;</span> <br><span class="token keyword">public</span><span class="token operator">:</span> <br>  <span class="token function">Dragon</span><span class="token punctuation">(</span><span class="token keyword">float</span> sz<span class="token punctuation">,</span> <span class="token keyword">float</span> h<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">{</span><br>    fire_temperature <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span> <span class="token comment">// in degrees Farenheit</span><br>  <span class="token punctuation">}</span><br>  <br>  <span class="token comment">// Increase fire temperature 10 degrees over 'seconds'</span><br>  <span class="token keyword">void</span> <span class="token function">take_breath</span><span class="token punctuation">(</span><span class="token keyword">float</span> seconds<span class="token punctuation">)</span><span class="token punctuation">{</span><br>    <span class="token comment">// the dragon sucks in air, preparing to fire breath</span><br>    fire_temperature <span class="token operator">+=</span> seconds<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <br>  <span class="token comment">// For every second the dragons rests, his breath temperature drops</span><br>  <span class="token comment">// as before, to a minimum of 200 degrees</span><br>  <span class="token keyword">void</span> <span class="token function">rest</span><span class="token punctuation">(</span><span class="token keyword">float</span> seconds<span class="token punctuation">)</span><span class="token punctuation">{</span><br>    fire_temperature <span class="token operator">-=</span> second<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span> <br>    fire_temperature <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span>fire_temperature<span class="token punctuation">,</span> <span class="token number">200.0</span><span class="token punctuation">)</span><br>  <span class="token punctuation">}</span><br>  <br>  <span class="token comment">// Breathes fire on the villagers</span><br>  <span class="token keyword">float</span> <span class="token function">breath_fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><br>    <span class="token keyword">float</span> output_fire <span class="token operator">=</span> height<span class="token operator">*</span>size<span class="token operator">*</span><span class="token function">take_breath</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <br>    <span class="token keyword">return</span><span class="token punctuation">(</span>output_fire<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br>Dragon d <span class="token operator">=</span> <span class="token function">Dragon</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><br><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><br> <br><span class="token comment">// const auto v = vector&lt; int >{ 1, 2, 3, 4, 5 };</span></code></pre>
<p>Notice that the dragons size and height are constant, but the dragon's temperature is mutated as the dragon rests or takes in a breath. This is the traditional object-oriented way of handling state. In this case, the use of the <code>class</code> keyword implies the member fields are <code>private</code> by default, whereas the member functions (and the constructor) are part of the public interface.</p>
<p>You can emulate the semantics of closures in C++ by using <em>function objects</em>, short for <em>functors</em>. These are unrelated to the category theory and FP definition of a functor. Function objects were made possible in the 1982 release of C++, colloquially now known as the version of C++ called &quot;<em>C with classes</em>&quot;.</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token comment">// Estimates 1/sqrt(x)</span><br><span class="token comment">// From: 1999 implementation of Quake 3: Arena </span><br><span class="token comment">// See also: https://www.youtube.com/watch?v=p8u_k2LIZyo</span><br><span class="token keyword">struct</span> <span class="token class-name">FastInvSqrt</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> <span class="token keyword">float</span> threehalfs <span class="token operator">=</span> <span class="token number">1.5F</span><span class="token punctuation">;</span><br>  <br>  <span class="token comment">// FastInvSqrt () { }</span><br>  <br>  <span class="token keyword">float</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><br>    <span class="token keyword">long</span> i<span class="token punctuation">;</span><br>    <span class="token keyword">float</span> x2<span class="token punctuation">,</span> y<span class="token punctuation">;</span><br>    x2 <span class="token operator">=</span> number <span class="token operator">*</span> <span class="token number">0.5F</span><span class="token punctuation">;</span><br>    y  <span class="token operator">=</span> number<span class="token punctuation">;</span><br>    i  <span class="token operator">=</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token keyword">long</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span>                       <span class="token comment">// evil floating point bit level hacking</span><br>    i  <span class="token operator">=</span> <span class="token number">0x5f3759df</span> <span class="token operator">-</span> <span class="token punctuation">(</span> i <span class="token operator">>></span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// what the fuck? </span><br>    y  <span class="token operator">=</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><br>    y  <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token punctuation">(</span> threehalfs <span class="token operator">-</span> <span class="token punctuation">(</span> x2 <span class="token operator">*</span> y <span class="token operator">*</span> y <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1st iteration</span><br>    <span class="token comment">//	y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed</span><br>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The idea is as follows: the struct defines a class with a default all-public namespace with only one member function, the operator <code>()</code>. Once an object is instantiated, the object can be used</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> inv_sqrt <span class="token operator">=</span> <span class="token function">FastInvSqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">inv_sqrt</span><span class="token punctuation">(</span><span class="token number">12.5</span><span class="token punctuation">)</span>  <br><span class="token comment">// => ~ 1/sqrt(12.5)</span></code></pre>
<p>Indeed, this object is a full-featured <strong>type</strong>. And C++ supports custom object types as first-class citizens. Thus, we can do the following:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">float</span> <span class="token function">apply_f</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> FastInvSqrt<span class="token operator">&amp;</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">auto</span> inv_sqrt <span class="token operator">=</span> <span class="token function">FastInvSqrt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">float</span> result <span class="token operator">=</span> <span class="token function">apply_f</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">,</span> inv_sqrt<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Does this mean that C++ is a FP language?</p>
<hr>
<p>Function objects end up being extremely useful for generic programming. For example, suppose you want to sort a container in C++ using the STL library function <code>std::sort</code>.</p>
<pre class="language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span> <span class="token keyword">int</span> <span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">// => v = [2, 4, 4, 5, 5, 7, 10]</span></code></pre>
<p>Observe <code>v</code> is sorted in ascending order. Suppose you wanted to sort <code>v</code> in descending order. How would you implement this?  One option is to add a boolean flag to the <code>std::sort</code> function:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> descending<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><br><span class="token punctuation">}</span></code></pre>
<p>However, this is not the approach taken by the STL. If one looks at the definition <code>std::sort</code>, the function signature is as follows:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">RandomIt</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">></span><br><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span> RandomIt first<span class="token punctuation">,</span> RandomIt last<span class="token punctuation">,</span> Compare comp <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Observe that sort takes a <em>comparator</em> as the third argument. Indeed, the default specialization for the <code>std::sort</code> above is:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">RandomIt</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">></span><br><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span> RandomIt first<span class="token punctuation">,</span> RandomIt last<span class="token punctuation">,</span> Compare comp <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span> T <span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>where the type <code>T</code> is deduced from the <code>value_type</code> of whatever type is associated with <code>RandomIt</code>, and <code>std::less&lt; T &gt;()</code> is a function object whose implementation looks something similar to the following:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">></span><br><span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token punctuation">{</span><br>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> lhs <span class="token operator">&lt;</span> rhs<span class="token punctuation">;</span> <span class="token comment">// assumes that T overloads the &lt; operator</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>In the context of <code>std::sort</code>, the functor <code>std::less</code> is a binary predicate which returns whether the first argument should go before second. Sorting a vector into a ascending order can be easily achieved:</p>
<pre class="language-cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br># <span class="token operator">=</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><br>std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br># <span class="token operator">=</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span></code></pre>
<p>But <code>std::sort</code> can actually sort any container. Consider the following container:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><br>  <span class="token keyword">float</span> x<span class="token punctuation">;</span><br>  <span class="token keyword">float</span> y<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token punctuation">{</span><br>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Point <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>x <span class="token operator">==</span> rhs<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  vector<span class="token operator">&lt;</span> Point <span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <br>  <span class="token comment">// How to sort v by the x-coordinates, with the y-coordinate as a tie-breaker?</span><br>  std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<hr>
<p>C++11 introduced the syntax for <em>Lambdas</em>, which are effectively anonymous function objects. A more detailed explanation of how the assembly of lambdas differs from functors is described <a href="https://web.mst.edu/~nmjxv3/articles/lambdas.html">here</a>. The basic syntax for a lambda is as follows:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token punctuation">[</span> captures <span class="token punctuation">]</span> <span class="token punctuation">(</span> params <span class="token punctuation">)</span> <span class="token punctuation">{</span> body <span class="token punctuation">}</span></code></pre>
<p>The best way to illustrate this is by showing an example:</p>
<pre class="language-cpp"><code class="language-cpp"> <span class="token keyword">struct</span> <span class="token class-name">Functor</span> <span class="token punctuation">{</span><br>   <span class="token function">Functor</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br> <br>   <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>     <span class="token keyword">return</span> a <span class="token operator">+</span> m_x<span class="token punctuation">;</span><br>   <span class="token punctuation">}</span><br>   <span class="token keyword">int</span> m_x<span class="token punctuation">;</span><br> <span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><br>  Functor <span class="token function">functor</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <br>  <span class="token comment">// This is identical to the above functor </span><br>  <span class="token keyword">auto</span> lambda <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <br>  <span class="token keyword">int</span> y1 <span class="token operator">=</span> <span class="token function">functor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => y1 == 8</span><br>  <br>  <span class="token keyword">int</span> y2 <span class="token operator">=</span> <span class="token function">lambda</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => y2 == 8</span><br>  <br>  <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>With the addition of anonymous lambdas to the C++ language, with a little bit of template programming, the following code is now possible:</p>
<pre class="language-cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><br><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Function</span> <span class="token operator">></span><br><span class="token keyword">double</span> <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> Function f<span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><br>  <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">,</span> add<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => 13.0</span><br>  <span class="token keyword">auto</span> add_lambda <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span><br>    <span class="token keyword">return</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token function">eval_binary</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">,</span> add_lambda<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token comment">// => 13.0</span><br><span class="token punctuation">}</span></code></pre>
<p>Does this mean that C++11 is a FP language?</p>
<h2>Bonus: coroutines</h2>
<blockquote>
<p>A coroutine is a generalisation of a function that allows the function to be suspended and then later resumed</p>
<ul>
<li>Lewis Baker</li>
</ul>
</blockquote>
<p>A function is a group of expressions allocated on a block of memory called an <strong>activation frame</strong> (or, if the memory is allocated on the stack, <em>stack-frame</em>), which supports two operations: <strong>Call</strong> and <strong>Return</strong>.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">peg_alex</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  strapon <span class="token operator">=</span> construct_strapon<span class="token punctuation">(</span>size<span class="token punctuation">)</span><br>  peg<span class="token punctuation">(</span>alex<span class="token punctuation">,</span> strapon<span class="token punctuation">)</span></code></pre>
<p>A coroutine a function that supports three additional operations: <strong>Suspend</strong>, <strong>Resume</strong>, and <strong>Destroy</strong>.</p>
<p><a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">https://lewissbaker.github.io/2017/09/25/coroutine-theory</a></p>
<p><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html</a></p>
<h2>Tail-call recursion</h2>
<p>From <a href="https://en.wikipedia.org/wiki/Tail_call">wiki</a>, for more reading. here are some examples/non-examples of (non-recursive) <em>tail call functions</em>:</p>
<pre><code>function foo1(data) {
    return (data) + 1;
}
function foo2(data) {
    var ret = g(data);
    return ret;
}
function foo3(data) {
    var ret = g(data);
    return (ret == 0) ? 1 : ret;
}
</code></pre>
<p><strong>foo1</strong> and <strong>foo3</strong> are not tail-call functions, as both modify the result of calling the function <strong>g</strong>. <strong>foo2</strong> is an example of function with a tail-call. Tail call recursion is important in functional languages. The use of tail-call recursion is sometimes called <strong>tail-call optimization</strong>, because one only needs a constant amount of stack space to call a tail-recursive function.</p>
<p>For example, here is a non-tail-recursive implementation of the factorial function ( <em>n!</em> ):</p>
<pre class="language-scheme"><code class="language-scheme"><span class="token comment">;; factorial : number -> number</span><br><span class="token comment">;; Calculates the product of all positive integers less than or equal to n.</span><br><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">factorial</span> n<span class="token punctuation">)</span><br> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">1</span><span class="token punctuation">)</span><br>    <span class="token number">1</span><br>    <span class="token punctuation">(</span><span class="token operator">*</span> n <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Upon evaluation, the stack-frame grows as follows:</p>
<pre class="language-scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">4</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token function">fact</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">4</span> <span class="token number">6</span><span class="token punctuation">)</span><br><span class="token number">24</span></code></pre>
<p>A tail recursive solution looks as follows:</p>
<pre class="language-scheme"><code class="language-scheme"><span class="token comment">;; factorial : number -> number</span><br><span class="token comment">;; Calculates the product of all positive integers less than or equal to n tail-recursively.</span><br><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">factorial</span> n<span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token function">fact-iter</span> <span class="token number">1</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">fact-iter</span> product n<span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span> n <span class="token number">2</span><span class="token punctuation">)</span><br>      product<br>      <span class="token punctuation">(</span><span class="token function">fact-iter</span> <span class="token punctuation">(</span><span class="token operator">*</span> product n<span class="token punctuation">)</span><br>                 <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Because of the tail-recursive nature of this function, the interpreter is free to optimize the recursion by <strong>replacing the contents of the existing stack-frame</strong> with the result of inner-most recursion. For example, instead of the stack-frame looking like this:</p>
<pre class="language-scheme"><code class="language-scheme"> call factorial <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><br>   call fact-iter <span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">4</span><span class="token punctuation">)</span><br>    call fact-iter <span class="token punctuation">(</span><span class="token number">4</span> <span class="token number">3</span><span class="token punctuation">)</span><br>     call fact-iter <span class="token punctuation">(</span><span class="token number">12</span> <span class="token number">2</span><span class="token punctuation">)</span><br>      call fact-iter <span class="token punctuation">(</span><span class="token number">24</span> <span class="token number">1</span><span class="token punctuation">)</span><br>      return <span class="token number">24</span><br>     return <span class="token number">24</span><br>    return <span class="token number">24</span><br>   return <span class="token number">24</span><br>  return <span class="token number">24</span></code></pre>
<p>The scheme interpreter would continually replace the contents of the existing stack frame  (parameters included!). The resulting tail-recursion would look as follows:</p>
<pre class="language-scheme"><code class="language-scheme"> call factorial <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><br>   call fact-iter <span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">4</span><span class="token punctuation">)</span><br>   replace arguments with <span class="token punctuation">(</span><span class="token number">4</span> <span class="token number">3</span><span class="token punctuation">)</span><br>   replace arguments with <span class="token punctuation">(</span><span class="token number">12</span> <span class="token number">2</span><span class="token punctuation">)</span><br>   replace arguments with <span class="token punctuation">(</span><span class="token number">24</span> <span class="token number">1</span><span class="token punctuation">)</span><br>   return <span class="token number">24</span><br>  return <span class="token number">24</span></code></pre>
<p>More reading: Look up <em>thunks</em>, <em>trampolining</em>, <em>applicative order evaluation</em>, and <em>continuation-passing style</em>.</p>
<h2>Exercises and Resources to try</h2>
<p>Python exercises: <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming</a></p>
<br/></div></div><script src="js/jquery.min.js"></script><script src="js/elasticlunr.min.js"></script><script src="js/lodash.min.js"></script><script>document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((block) => {
    console.log("here");
    //hljs.highlightBlock(block);
  });
});</script><script>const tabs = ["home_tab", "about_tab"];
tabs.forEach((tab_id) => {
	var tab_el = document.getElementById(tab_id)
	console.log(window.location.pathname.replace("/", ""))
	console.log(tab_el.pathname.replace("/", ""))
	if (window.location.pathname == tab_el.pathname){
		console.log("orange")
		tab_el.classList.remove("text-black")
		tab_el.classList.add("text-orange")
	} else {
		console.log("black")
		tab_el.classList.remove("text-orange")
		tab_el.classList.add("text-black")
	}
})</script><script>var search_index, doc_keys;

const apply_slugs = (slugs, display_status) => {
	_.forEach(slugs, (id) => { if (id){ $("#"+id).css("display", display_status); } });
};

$.getJSON('data/cached_index.json', function(data) {
	search_index = elasticlunr.Index.load(data);
	doc_keys = _.map(search_index.documentStore.docs, (doc) => {
		return (doc.slug ? doc.slug : "");
	});
	console.log("Search index")
	console.log(search_index);
});


const feed = $("#article_feed");
const all_articles = $("#article_feed").children();
//- const article_ids = _.map(all_articles, (article) => { 
//- 	return article.id.replace(/-/g, "_")
//- })	

console.log("Articles: ")
console.log(all_articles)

function update_search_box() {
	var searchstring = $('#search_box');
	searchstring.focus();
	
	console.log(searchstring.val())

	// If query empty, default to listing all the articles
	if (searchstring.val().trim() == ""){
		if (feed.children().length != all_articles.length){
			feed.children().detach()
			feed.append(all_articles);
		}
	} else {
		var res = search_index.search(searchstring.val(), {});
		const found_slugs = _.map(res, (doc) => { return doc.ref; });
		console.log(found_slugs)
		const ordered_articles = _.map(found_slugs, (slug) => {
			return _.find(all_articles, (article) => { return article.id.replace(/-/g, "_") == slug.replace(/-/g, "_") });
		});
		feed.children().detach()
		_.forEach(ordered_articles, (arr) => {
			feed.append(arr);
			feed.append(document.createElement("br"))
		});
	}
}
$( "#search_box" ).keyup(update_search_box);</script></body><footer class="fixed text-center bottom-0 bg-gray-100 border w-full"><span>&copy; Copyright Matt Piekenbrock 2022. Proudly powered by </span><a href="https://www.11ty.dev/">Eleventy.</a><script>$(document).ready(function() {
  $("[data-link]").click(function() {
    window.location.href = $(this).attr("data-link");
    return false;
  });
});</script></footer></html>